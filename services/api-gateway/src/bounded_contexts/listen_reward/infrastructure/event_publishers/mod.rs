// Event Publishing Infrastructure for Listen Reward Context
//
// This module provides infrastructure for publishing domain events
// generated by the Listen Reward bounded context to other parts of
// the system and external services.

use async_trait::async_trait;
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::sync::Arc;
use tokio::sync::mpsc;
use std::collections::HashMap;
use sqlx::PgPool;

use crate::shared::domain::events::DomainEvent;
use crate::shared::domain::errors::AppError;

mod postgres_event_publisher;
mod redis_stream_event_publisher;
mod event_publisher_trait;
mod event_processor;
mod in_memory_event_publisher;

pub use postgres_event_publisher::PostgresEventPublisher;
pub use redis_stream_event_publisher::RedisStreamEventPublisher;
pub use in_memory_event_publisher::InMemoryEventPublisher;

/// Resultado de la publicación de un evento
#[derive(Debug, Clone)]
pub struct EventPublishResult {
    pub event_id: Uuid,
    pub success: bool,
    pub timestamp: DateTime<Utc>,
    pub error_message: Option<String>,
}

impl EventPublishResult {
    pub fn success(event_id: Uuid) -> Self {
        Self {
            event_id,
            success: true,
            timestamp: Utc::now(),
            error_message: None,
        }
    }

    pub fn failure(event_id: Uuid, error: String) -> Self {
        Self {
            event_id,
            success: false,
            timestamp: Utc::now(),
            error_message: Some(error),
        }
    }
}

/// Metadatos del evento
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventMetadata {
    pub event_id: Uuid,
    pub event_type: String,
    pub aggregate_id: Uuid,
    pub aggregate_type: String,
    pub timestamp: DateTime<Utc>,
}

impl EventMetadata {
    pub fn new(event_type: String, aggregate_id: Uuid, aggregate_type: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            event_type,
            aggregate_id,
            aggregate_type,
            timestamp: Utc::now(),
        }
    }
}

/// Trait para publicar eventos de dominio
#[async_trait]
pub trait EventPublisher: Send + Sync {
    /// Publica un evento
    async fn publish_event(&self, event: Box<dyn DomainEvent>) -> Result<EventPublishResult, String>;

    /// Publica múltiples eventos
    async fn publish_events(&self, events: Vec<Box<dyn DomainEvent>>) -> Vec<Result<EventPublishResult, String>>;

    /// Comprueba si el publicador está disponible
    async fn is_healthy(&self) -> bool;
}

/// Factory para crear publicadores de eventos según la configuración
pub struct EventPublisherFactory {
    pool: PgPool,
}

impl EventPublisherFactory {
    pub async fn new(pool: PgPool) -> Result<Self, String> {
        Ok(Self { pool })
    }

    /// Crea un publicador de PostgreSQL
    pub async fn create_postgres_publisher(&self) -> Result<Box<dyn EventPublisher>, String> {
        let publisher = PostgresEventPublisher::new(self.pool.clone());
        Ok(Box::new(publisher))
    }

    /// Crea un publicador de Redis Stream
    pub async fn create_redis_stream_publisher(&self, redis_url: &str, stream_key: &str) -> Result<Box<dyn EventPublisher>, String> {
        let publisher = RedisStreamEventPublisher::new(redis_url, stream_key.to_string())?;
        Ok(Box::new(publisher))
    }

    /// Crea un publicador de eventos según el tipo especificado (método legacy)
    pub async fn create(&self, publisher_type: &str, config: &serde_json::Value) -> Result<Box<dyn EventPublisher>, String> {
        match publisher_type {
            "postgres" => {
                let connection_string = config["connection_string"]
                    .as_str()
                    .ok_or("Missing connection_string for Postgres publisher")?;
                
                // Use the internal pool instead of creating a new one
                self.create_postgres_publisher().await
            },
            "redis_stream" => {
                let redis_url = config["redis_url"]
                    .as_str()
                    .ok_or("Missing redis_url for Redis Stream publisher")?;
                
                let stream_key = config["stream_key"]
                    .as_str()
                    .unwrap_or("listen_reward:events");
                
                self.create_redis_stream_publisher(redis_url, stream_key).await
            },
            _ => Err(format!("Unsupported event publisher type: {}", publisher_type)),
        }
    }
} 